{"version":3,"file":"/packages/reststop2.js","sources":["reststop2/server.js","reststop2/routing.js","reststop2/auth.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;AAAA,wB;AACA,oB;AACA,kB;AACA,oB;AACA,qB;AACA,6B;AACA,6B;AACA,I;AACA,wB;AACA,E;;AAEA,0C;AACA,8D;AACA,kB;;AAEA,uC;;AAEA,sC;AACA,qB;AACA,kB;AACA,G;;AAEA,+C;AACA,wC;AACA,4B;AACA,O;AACA,U;AACA,qB;AACA,kE;AACA,yB;AACA,qB;AACA,K;AACA,mC;AACA,oD;AACA,K;AACA,6F;AACA,G;AACA,E;;AAEA,yD;AACA,iD;AACA,6C;;AAEA,8D;AACA,uE;;AAEA,oB;AACA,qC;AACA,uC;;AAEA,+D;AACA,+C;AACA,O;AACA,4D;AACA,gD;AACA,O;;AAEA,iC;AACA,6B;;AAEA,2C;AACA,mD;;AAEA,8C;AACA,wD;AACA,S;AACA,0C;AACA,gD;AACA,S;;AAEA,8B;AACA,kC;AACA,+C;AACA,yB;AACA,2D;AACA,a;AACA,S;;AAEA,wD;AACA,6D;AACA,uF;AACA,S;AACA,O;;AAEA,W;AACA,6C;AACA,mB;AACA,kF;AACA,O;AACA,K;AACA,G;AACA,e;AACA,E;;AAEA,iD;AACA,oB;AACA,iG;AACA,G;;AAEA,iC;;AAEA,uC;AACA,wD;AACA,G;AACA,E;;AAEA,wC;AACA,kB;;AAEA,oB;AACA,yD;AACA,G;;AAEA,uB;;AAEA,wB;AACA,oE;;AAEA,kB;AACA,uC;;AAEA,8C;AACA,mD;AACA,uD;AACA,mF;AACA,oB;AACA,K;;AAEA,8D;AACA,6B;AACA,iE;;AAEA,sB;AACA,uD;AACA,4C;;AAEA,6B;AACA,yE;AACA,O;AACA,M;AACA,2D;;AAEA,qB;AACA,iE;AACA,8B;AACA,6D;AACA,iC;;AAEA,kC;AACA,+C;AACA,gD;AACA,sC;AACA,a;AACA,S;;AAEA,kC;AACA,0C;AACA,S;;AAEA,2B;AACA,O;;AAEA,+B;AACA,gC;AACA,oB;AACA,O;;AAEA,8B;AACA,wC;AACA,mD;AACA,O;;AAEA,6B;AACA,a;AACA,K;;AAEA,6B;AACA,wB;AACA,G;AACA,E;;AAEA,4D;AACA,sD;AACA,6D;AACA,E;;AAEA,6D;AACA,6D;AACA,E;;AAEA,oE;AACA,8D;AACA,E;;AAEA,uC;AACA,kB;;AAEA,sE;AACA,qE;AACA,iE;AACA,gE;AACA,wE;AACA,sE;AACA,yC;AACA,2C;;AAEA,mE;AACA,qE;AACA,c;AACA,oD;AACA,8B;;AAEA,oB;AACA,+B;;AAEA,gE;AACA,yB;AACA,wD;;AAEA,uE;AACA,6D;AACA,iE;;AAEA,uE;AACA,+D;AACA,oE;AACA,2B;AACA,0C;AACA,E;;AAEA,sC;AACA,wB;AACA,oB;AACA,+B;AACA,oB;AACA,I;AACA,+B;AACA,oB;AACA,4B;AACA,gF;AACA,yB;AACA,4B;AACA,I;AACA,oC;AACA,+B;AACA,yC;AACA,I;AACA,oC;AACA,wC;AACA,G;AACA,G;;AAEA,4E;AACA,mC;;AAEA,oB;AACA,yC;AACA,gB;AACA,iB;AACA,0D;AACA,U;;AAEA,wD;AACA,gC;AACA,gF;AACA,M;;AAEA,2C;AACA,0B;AACA,qD;AACA,mC;AACA,O;;AAEA,S;AACA,6E;AACA,wC;AACA,wE;AACA,S;AACA,iB;AACA,oB;AACA,K;AACA,G;;AAEA,gB;AACA,oB;AACA,gB;AACA,E;;AAEA,yE;AACA,oB;AACA,yC;AACA,kD;AACA,qC;AACA,G;AACA,gC;AACA,E;;AAEA,4B;AACA,2B;;;;;;;;;;;;;;;;;;;AC1SA,0D;AACA,E;AACA,+D;AACA,E;AACA,G;AACA,4E;AACA,E;AACA,W;AACA,E;AACA,sF;AACA,kD;AACA,iE;AACA,E;AACA,uB;AACA,2B;AACA,e;AACA,G;;AAEA,0C;AACA,+B;AACA,mB;AACA,oC;;AAEA,8C;AACA,kC;AACA,G;AACA,mB;AACA,+E;AACA,G;;AAEA,iC;AACA,oB;AACA,4B;AACA,2B;AACA,C;;AAEA,G;AACA,kE;AACA,qB;AACA,E;AACA,uB;AACA,yB;AACA,wB;AACA,oB;AACA,e;AACA,G;;AAEA,gE;AACA,iC;;AAEA,mE;;AAEA,mB;AACA,8B;AACA,sD;AACA,iC;;AAEA,uB;;AAEA,iD;AACA,0B;;AAEA,qC;AACA,gC;AACA,a;;AAEA,c;AACA,uD;AACA,0B;AACA,c;AACA,Y;AACA,uB;AACA,K;AACA,G;;AAEA,c;AACA,E;;AAEA,G;AACA,mC;AACA,kC;AACA,E;AACA,mC;AACA,qC;AACA,0C;AACA,uB;AACA,E;AACA,qC;AACA,uB;AACA,8B;AACA,2B;AACA,mB;AACA,e;AACA,G;;AAEA,sD;AACA,0C;AACA,+D;AACA,a;AACA,+B;AACA,6B;AACA,+B;AACA,wG;AACA,sD;AACA,0B;AACA,e;AACA,iC;AACA,e;AACA,iC;AACA,mF;AACA,2B;AACA,M;AACA,gC;AACA,iC;AACA,4B;AACA,E;AACA,4D;AACA,E;;AAEA,oB;;AAEA,gE;;AAEA,G;AACA,2E;AACA,8B;AACA,E;AACA,2E;AACA,E;AACA,yB;AACA,iE;AACA,gB;;AAEA,U;AACA,uD;AACA,oD;AACA,0B;AACA,E;AACA,+D;AACA,kB;AACA,uB;AACA,Y;AACA,uB;AACA,M;AACA,uE;AACA,+D;AACA,K;AACA,+C;AACA,E;AACA,0B;AACA,E;AACA,4D;AACA,mC;AACA,qC;AACA,Y;AACA,I;AACA,4B;AACA,yB;AACA,Q;AACA,oB;AACA,I;AACA,uC;AACA,I;AACA,E;AACA,iD;;AAEA,c;AACA,C;;;;;;;;;;;;;;;;;;;ACvKA,sD;AACA,e;AACA,+B;AACA,qC;AACA,iC;AACA,K;AACA,gC;AACA,uE;AACA,c;AACA,G;;AAEA,6C;AACA,c;AACA,0B;AACA,yB;AACA,qC;AACA,sB;AACA,0C;AACA,oE;AACA,E;;AAEA,4C;AACA,yC;AACA,qC;;AAEA,+D;;AAEA,qD;AACA,4C;AACA,Y;AACA,kD;;AAEA,kD;AACA,8B;AACA,0D;;AAEA,mE;AACA,mD;AACA,4C;AACA,4D;AACA,uD;;AAEA,mD;AACA,wD;;AAEA,kE;AACA,wB;AACA,2E;;AAEA,mE;AACA,E;;AAEA,2C;AACA,wD;AACA,kB;AACA,6C;AACA,uC;AACA,Y;AACA,oC;AACA,K;;AAEA,S;AACA,qC;AACA,qB;AACA,wC;AACA,S;AACA,gB;AACA,4D;AACA,K;;AAEA,0B;AACA,qB;AACA,0C;AACA,2C;AACA,2B;AACA,6D;AACA,S;AACA,K;AACA,+C;;AAEA,yB;AACA,iB;AACA,K;;AAEA,6E;AACA,4C;AACA,+C;AACA,yD;AACA,K;;AAEA,uB;AACA,wB;AACA,kF;;AAEA,4C;;AAEA,+D;AACA,K;AACA,E","sourcesContent":["_RESTstop = function() {\n  this._routes = [];\n  this._config = {\n    use_auth: false,\n    api_path: '/api',\n    onLoggedIn: function(){},\n    onLoggedOut: function(){}\n  };\n  this._started = false;\n};\n\n// simply match this path to this function\n_RESTstop.prototype.add = function(path, options, endpoint)  {\n  var self = this;\n\n  if(path[0] != \"/\") path = \"/\" + path;\n\n  // Start serving on first add() call\n  if(!this._started){\n    this._start();\n  }\n\n  if (_.isObject(path) && ! _.isRegExp(path)) {\n    _.each(path, function(endpoint, p) {\n      self.add(p, endpoint);\n    });\n  } else {\n    if (! endpoint) {\n      // no options were supplied so 2nd parameter is the endpoint\n      endpoint = options;\n      options = null;\n    }\n    if (! _.isFunction(endpoint)) {\n      endpoint = _.bind(_.identity, null, endpoint);\n    }\n    self._routes.push([new RESTstop.Route(self._config.api_path + path, options), endpoint]);\n  }\n};\n\n_RESTstop.prototype.match = function(request, response) {\n  for (var i = 0; i < this._routes.length; i++) {\n    var params = {}, route = this._routes[i];\n\n    if (route[0].match(request.url, request.method, params)) {\n      context = {request: request, response: response, params: params};\n\n      var args = [];\n      for (var key in context.params)\n        args.push(context.params[key]);\n\n      if(request.method == \"POST\" || request.method == \"PUT\") {\n        _.extend(context.params, request.body);\n      }\n      if(request.method == \"GET\" || _.size(request.query)) {\n        _.extend(context.params, request.query);\n      }\n\n      if(this._config.use_auth) {\n        context.user = false;\n\n        var userId = context.params.userId;\n        var loginToken = context.params.loginToken;\n\n        if(request.headers['x-login-token']) {\n          loginToken = request.headers['x-login-token'];\n        }\n        if(request.headers['x-user-id']) {\n          userId = request.headers['x-user-id'];\n        }\n\n        // Get the user object\n        if(userId && loginToken) {\n          context.user = Meteor.users.findOne({\n            _id: userId, \n            \"services.resume.loginTokens.token\": loginToken\n          });\n        }\n\n        // Return an error if no user and login required\n        if(route[0].options.require_login && !context.user) {\n          return [403, {success: false, message: \"You must be logged in to do this.\"}];\n        }\n      }\n\n      try {\n        return route[1].apply(context, args);\n      } catch (e) {\n        return [e.error || 404, {success: false, message: e.reason || e.message}];\n      }\n    }\n  }\n  return false;\n};\n\n_RESTstop.prototype.configure = function(config){\n  if(this._started){\n    throw new Error(\"RESTstop.configure() has to be called before first call to RESTstop.add()\");\n  }\n\n  _.extend(this._config, config);\n\n  if(this._config.api_path[0] != \"/\") {\n    this._config.api_path = \"/\"  +this._config.api_path;\n  }\n};\n\n_RESTstop.prototype._start = function(){\n  var self = this;\n\n  if(this._started){\n    throw new Error(\"RESTstop has already been started\");\n  }\n\n  this._started = true;\n\n  // hook up the serving\n  RoutePolicy.declare('/' + this._config.api_path + '/', 'network');\n\n  var self = this,\n      connect = Npm.require(\"connect\");\n\n  WebApp.connectHandlers.use(connect.query());\n  WebApp.connectHandlers.use(connect.bodyParser());\n  WebApp.connectHandlers.use(function(req, res, next) {\n    if (req.url.slice(0, self._config.api_path.length) !== self._config.api_path) {\n      return next();\n    }\n\n    // need to wrap in a fiber in case they do something async\n    // (e.g. in the database)\n    if(typeof(Fiber)==\"undefined\") Fiber = Npm.require('fibers');\n\n    Fiber(function() {\n      res.statusCode = 200; // 200 response, by default\n      var output = RESTstop.match(req, res);\n\n      if (output === false) {\n        output = [404, {success: false, message:'API method not found'}];\n      }\n      \n      // parse out the various type of response we can have\n\n      // array can be\n      // [content], [status, content], [status, headers, content]\n      if (_.isArray(output)) {\n        // copy the array so we aren't actually modifying it!\n        output = output.slice(0);\n\n        if (output.length === 3) {\n          var headers = output.splice(1, 1)[0];\n          _.each(headers, function(value, key) {\n            res.setHeader(key, value);\n          });\n        }\n\n        if (output.length === 2) {\n          res.statusCode = output.shift();\n        }\n\n        output = output[0];\n      }\n\n      if (_.isNumber(output)) {\n        res.statusCode = output;\n        output = '';\n      }\n\n      if(_.isObject(output)) {\n        output = JSON.stringify(output);\n        res.setHeader(\"Content-Type\", \"text/json\");\n      }\n\n      return res.end(output);\n    }).run();\n  });\n\n  if(this._config.use_auth) {\n    RESTstop.initAuth();\n  }\n};\n\n_RESTstop.prototype.call = function (context, name, args) { \n  var args = Array.prototype.slice.call(arguments, 2);\n  return this._apply(context, name, args, 'method_handlers');\n};\n\n_RESTstop.prototype.apply = function (context, name, args) { \n  return this._apply(context, name, args, 'method_handlers');\n};\n\n_RESTstop.prototype.getPublished = function (context, name, args) { \n  return this._apply(context, name, args, 'publish_handlers');\n};\n\nMethodInvocation = function (options) {\n  var self = this;\n\n  // true if we're running not the actual method, but a stub (that is,\n  // if we're on a client (which may be a browser, or in the future a\n  // server connecting to another server) and presently running a\n  // simulation of a server-side method for latency compensation\n  // purposes). not currently true except in a client such as a browser,\n  // since there's usually no point in running stubs unless you have a\n  // zero-latency connection to the user.\n  this.isSimulation = options.isSimulation;\n\n  // call this function to allow other method invocations (from the\n  // same client) to continue running without waiting for this one to\n  // complete.\n  this._unblock = options.unblock || function () {};\n  this._calledUnblock = false;\n\n  // current user id\n  this.userId = options.userId;\n\n  // sets current user id in all appropriate server contexts and\n  // reruns subscriptions\n  this._setUserId = options.setUserId || function () {};\n\n  // used for associating the connection with a login token so that the\n  // connection can be closed if the token is no longer valid\n  this._setLoginToken = options._setLoginToken || function () {};\n\n  // Scratch data scoped to this connection (livedata_connection on the\n  // client, livedata_session on the server). This is only used\n  // internally, but we should have real and documented API for this\n  // sort of thing someday.\n  this._sessionData = options.sessionData;\n};\n\n_.extend(MethodInvocation.prototype, {\n  unblock: function () {\n    var self = this;\n    self._calledUnblock = true;\n    self._unblock();\n  },\n  setUserId: function(userId) {\n    var self = this;\n    if (self._calledUnblock)\n      throw new Error(\"Can't call setUserId in a method after calling unblock\");\n    self.userId = userId;\n    self._setUserId(userId);\n  },\n  _setLoginToken: function (token) {\n    this._setLoginToken(token);\n    this._sessionData.loginToken = token;\n  },\n  _getLoginToken: function (token) {\n    return this._sessionData.loginToken;\n  }\n});\n\n_RESTstop.prototype._apply = function (context, name, args, handler_name) { \n  var self = Meteor.default_server;\n\n  // Run the handler\n  var handler = self[handler_name][name];\n  var exception;\n  if (!handler) {\n    exception = new Meteor.Error(404, \"Method not found\");\n  } else {\n\n    var userId = context.user ? context.user._id : null;\n    var setUserId = function() {\n      throw new Error(\"Can't call setUserId on a server initiated method call\");\n    };\n\n    var invocation = new MethodInvocation({\n      isSimulation: false,\n      userId: context.user._id, setUserId: setUserId,\n      sessionData: self.sessionData\n    });\n\n    try {\n      var result = DDP._CurrentInvocation.withValue(invocation, function () {\n        return maybeAuditArgumentChecks(\n          handler, invocation, args, \"internal call to '\" + name + \"'\");\n      });\n    } catch (e) {\n      exception = e;\n    }\n  }\n\n  if (exception)\n    throw exception;\n  return result;\n};\n\nvar maybeAuditArgumentChecks = function (f, context, args, description) {\n  args = args || [];\n  if (Package['audit-argument-checks']) {\n    return Match._failIfArgumentsAreNotAllChecked(\n      f, context, args, description);\n  }\n  return f.apply(context, args);\n};\n\n// Make the router available\nRESTstop = new _RESTstop();\n","// Route object taken from page.js, slightly stripped down\n//\n// Copyright (c) 2012 TJ Holowaychuk &lt;tj@vision-media.ca&gt;\n//\n/**\n * Initialize `Route` with the given HTTP `path`, and an array of `options`.\n *\n * Options:\n *\n *   - `methods`      the allowed methods. string (\"POST\") or array ([\"POST\", \"GET\"]).\n *   - `sensitive`    enable case-sensitive routes\n *   - `strict`       enable strict matching for trailing slashes\n *\n * @param {String} path\n * @param {Object} options.\n * @api private\n */\n\nRESTstop.Route = function(path, options) {\n  this.options = options || {};\n  this.path = path;\n  this.method = this.options.method;\n\n  if(this.method && !_.isArray(this.method)) {\n      this.method = [this.method];\n  }\n  if(this.method) {\n      this.method = _.map(this.method, function(s){ return s.toUpperCase(); });\n  }\n\n  this.regexp = pathtoRegexp(path\n    , this.keys = []\n    , this.options.sensitive\n    , this.options.strict);\n}\n\n/**\n * Check if this route matches `path` and optional `method`, if so\n * populate `params`.\n *\n * @param {String} path\n * @param {String} method\n * @param {Array} params\n * @return {Boolean}\n * @api private\n */\n\nRESTstop.Route.prototype.match = function(path, method, params){\n  var keys, qsIndex, pathname, m;\n\n  if(this.method && !_.contains(this.method, method)) return false;\n\n  keys = this.keys;\n  qsIndex = path.indexOf('?');\n  pathname = ~qsIndex ? path.slice(0, qsIndex) : path;\n  m = this.regexp.exec(pathname);\n\n  if (!m) return false;\n\n  for (var i = 1, len = m.length; i < len; ++i) {\n    var key = keys[i - 1];\n\n    var val = 'string' == typeof m[i]\n      ? decodeURIComponent(m[i])\n      : m[i];\n\n    if (key) {\n      params[key.name] = undefined !== params[key.name]\n        ? params[key.name]\n        : val;\n    } else {\n      params.push(val);\n    }\n  }\n\n  return true;\n};\n\n/**\n * Normalize the given path string,\n * returning a regular expression.\n *\n * An empty array should be passed,\n * which will contain the placeholder\n * key names. For example \"/user/:id\" will\n * then contain [\"id\"].\n *\n * @param  {String|RegExp|Array} path\n * @param  {Array} keys\n * @param  {Boolean} sensitive\n * @param  {Boolean} strict\n * @return {RegExp}\n * @api private\n */\n\nfunction pathtoRegexp(path, keys, sensitive, strict) {\n  if (path instanceof RegExp) return path;\n  if (path instanceof Array) path = '(' + path.join('|') + ')';\n  path = path\n    .concat(strict ? '' : '/?')\n    .replace(/\\/\\(/g, '(?:/')\n    .replace(/\\+/g, '__plus__')\n    .replace(/(\\/)?(\\.)?:(\\w+)(?:(\\(.*?\\)))?(\\?)?/g, function(_, slash, format, key, capture, optional){\n      keys.push({ name: key, optional: !! optional });\n      slash = slash || '';\n      return ''\n        + (optional ? '' : slash)\n        + '(?:'\n        + (optional ? slash : '')\n        + (format || '') + (capture || (format && '([^/.]+?)' || '([^/]+?)')) + ')'\n        + (optional || '');\n    })\n    .replace(/([\\/.])/g, '\\\\$1')\n    .replace(/__plus__/g, '(.+)')\n    .replace(/\\*/g, '(.*)');\n  \n  return new RegExp('^' + path + '$', sensitive ? '' : 'i');\n};\n\n/// END Route object\n\n// Added by tom, lifted from mini-pages, with some modifications\n\n/**\n  Given a context object, returns a url path with the values of the context\n  object mapped over the path.\n  \n  Alternatively, supply the named parts of the paths as discrete arguments.\n  \n  @method pathWithContext\n  @param [context] {Object} An optional context object to use for\n  interpolation.\n\n  @example\n      // given a page with a path of \"/posts/:_id/edit\"\n      var path = page.pathWithContext({ _id: 123 });\n      // > /posts/123/edit\n*/\nRESTstop.Route.prototype.pathWithContext = function (context) {\n  var self = this,\n      path = self.path,\n      parts,\n      args = arguments;\n      \n  /* get an array of keys from the path to replace with context values.\n  /* XXX Right now this comes from page-js. Remove dependency. \n   */\n  parts = self.regexp.exec(self.path).slice(1);\n  \n  context = context || {};\n  \n  var replacePathPartWithContextValue = function (part, i) {\n    var re = new RegExp(part, \"g\"),\n        prop = part.replace(\":\", \"\"),\n        val;\n    \n    if (_.isObject(context))\n      val = context[prop]\n    else\n      val = args[i];\n    \n    path = path.replace(re, val || '');\n  };\n  \n  _.each(parts, replacePathPartWithContextValue);\n\n  return path;\n}\n","var userQueryValidator = Match.Where(function (user) {\n  check(user, {\n    id: Match.Optional(String),\n    username: Match.Optional(String),\n    email: Match.Optional(String)\n  });\n  if (_.keys(user).length !== 1)\n    throw new Match.Error(\"User property must have exactly one field\");\n  return true;\n});\n\nvar selectorFromUserQuery = function (user) {\n  if (user.id)\n    return {_id: user.id};\n  else if (user.username)\n    return {username: user.username};\n  else if (user.email)\n    return {\"emails.address\": user.email};\n  throw new Error(\"shouldn't happen (validation missed something)\");\n};\n\nvar loginWithPassword = function (options) {\n  if (!options.password || !options.user)\n    return undefined; // don't handle\n\n  check(options, {user: userQueryValidator, password: String});\n\n  var selector = selectorFromUserQuery(options.user);\n  var user = Meteor.users.findOne(selector);\n  if (!user)\n    throw new Meteor.Error(403, \"User not found\");\n\n  if (!user.services || !user.services.password ||\n  !user.services.password.srp)\n  throw new Meteor.Error(403, \"User has no password set\");\n\n  // Just check the verifier output when the same identity and salt\n  // are passed. Don't bother with a full exchange.\n  var verifier = user.services.password.srp;\n  var newVerifier = SRP.generateVerifier(options.password, {\n    identity: verifier.identity, salt: verifier.salt});\n\n    if (verifier.verifier !== newVerifier.verifier)\n      throw new Meteor.Error(403, \"Incorrect password\");\n\n    var stampedLoginToken = Accounts._generateStampedLoginToken();\n    Meteor.users.update(\n    user._id, {$push: {'services.resume.loginTokens': stampedLoginToken}});\n\n    return {loginToken: stampedLoginToken.token, userId: user._id};\n};\n\n_RESTstop.prototype.initAuth = function() {\n  RESTstop.add('login', {'method': 'POST'}, function() {\n    var user = {};\n    if(this.params.user.indexOf('@') == -1) {\n      user.username = this.params.user;\n    } else {\n      user.email = this.params.user;\n    }\n\n    try {\n      var login = loginWithPassword({\n        'user': user,\n        'password': this.params.password\n      });\n    } catch(e) {\n      return [e.error, {success: false, message: e.reason}];\n    }\n\n    // Get the user object\n    var context = [];\n    if(login.userId && login.loginToken) {\n      context.user = Meteor.users.findOne({\n        _id: login.userId, \n        \"services.resume.loginTokens.token\": login.loginToken\n      });\n    }\n    RESTstop._config.onLoggedIn.apply(context);\n\n    login.success = true;\n    return login;\n  });\n\n  RESTstop.add('logout', {'method': 'GET', require_login: true}, function() {\n    var loginToken = this.params.loginToken;\n    if(this.request.headers['x-login-token']) {\n      loginToken = this.request.headers['x-login-token'];\n    }\n\n    // Log the user out\n    Meteor.users.update(\n    this.user._id, {$pull: {'services.resume.loginTokens': {token: loginToken}}});\n\n    RESTstop._config.onLoggedOut.call(this);\n\n    return {success: true, message: \"You've been logged out!\"};\n  });\n};\n"]}